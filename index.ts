import Web3 from "web3";
const fs = require("fs");
const solc = require("solc");
import { Contract, DeployOptions } from "web3-eth-contract";
const axios = require("axios").default;
//example command to test
//npx tsc &&node build/index.js


(async function run() {

    const web3Provider = new Web3.providers.WebsocketProvider("HTTP://127.0.0.1:7545");
    const web3 = new Web3(web3Provider);


    // account_pri_key is an account generated by Ganache
    let account = web3.eth.accounts.wallet.add("0x" + "82b177e843fa6194fb7bdc952b3a513d5be6879b0f2225599df7950967199bc1");


    function findImports(importPath: string) {
        try {
            return {
                    contents: fs.readFileSync(`smart_contracts/${importPath}`, "utf8")
                };
        } catch (e:any) {
            return {
                error: e.message
            };
        }
    }

    // complile the solidity code
    function compileSols(solNames: string[]): any {
        interface SolCollection { [key: string]: any };
        let sources: SolCollection = {};
        solNames.forEach((value: string, index: number, array: string[]) => {
            let sol_file = fs.readFileSync(`smart_contracts/${value}.sol`, "utf8");
            sources[value] = {
                content: sol_file
            };
        });
        let input = {
            language: "Solidity",
            sources: sources,
            settings: {
                outputSelection: {
                    "*": {
                        "*": ["*"]
                    }
                }
            }
        };
        let compiler_output = solc.compile(JSON.stringify(input), {
            import: findImports
        });
        let output = JSON.parse(compiler_output);
        return output;
    }
    let compiled = compileSols(["inventory","roles"]);

    console.log("compiled");
    //console.log(compiled.contracts.example.FUNCNAME);

    // deploy contract
    let contract_instance1: Contract;
    let gasPrice1: string;
    let contract1 = new web3.eth.Contract(compiled.contracts["roles"]["Roles"].abi,
        undefined, {
            data: "0x" + compiled.contracts["roles"]["Roles"].evm.bytecode.object
        });
    await web3.eth.getGasPrice().then((averageGasPrice) => {
        gasPrice1 = averageGasPrice;
    }).catch(console.error);
    
    console.log("ready deploy")
    //console.log(contract)

    // assume account balance is sufficient
    await contract1.deploy({
        data: contract1.options.data,
        //arguments: [account.address]
    } as DeployOptions).send({
        from: account.address,
        gasPrice: gasPrice1!,
        gas: Math.ceil(1.2 * await contract1.deploy({
            data: contract1.options.data,
            //arguments: [account.address]
        } as DeployOptions).estimateGas({
            from: account.address
        })),
    }).then((instance) => {
        contract_instance1 = instance;
    }).catch(console.error);
    
    
    console.log(contract_instance1!.options.address);//address of the deployed contract

    
    let contract_instance: Contract;
    let gasPrice: string;
    let contract = new web3.eth.Contract(compiled.contracts["inventory"]["Inventory"].abi,
        undefined, {
            data: "0x" + compiled.contracts["inventory"]["Inventory"].evm.bytecode.object
        });
    await web3.eth.getGasPrice().then((averageGasPrice) => {
        gasPrice = averageGasPrice;
    }).catch(console.error);
    
    console.log("ready deploy")
    //console.log(contract)

    // assume account balance is sufficient
    await contract.deploy({
        data: contract.options.data,
        //arguments: [account.address]
    } as DeployOptions).send({
        from: account.address,
        gasPrice: gasPrice!,
        gas: Math.ceil(1.2 * await contract.deploy({
            data: contract.options.data,
            //arguments: [account.address]
        } as DeployOptions).estimateGas({
            from: account.address
        })),
    }).then((instance) => {
        contract_instance = instance;
    }).catch(console.error);
    
    
    console.log(contract_instance!.options.address);//address of the deployed contract
    //listen for smart contract event
    //invoked


    //run some test
    try{
        contract_instance!.methods.date().call().then(function(response: any){
            console.log(response)
            //return response;
        })
        contract_instance!.methods.checkIndex().call().then(function(response: any){
            console.log(response)
            //return response;
        })
        contract_instance!.methods.dayexpire().call().then(function(response: any){
            console.log(response)
            //return response;
        })
    } catch (e) {
        console.log(e);
    }
    

    //datetime oracle

    contract_instance!.events["dateRequest(string)"]()
        .on("connected", function (subscriptionId: any) {
            console.log("listening on event dateRequest");
        })
        //datetime oracle get
        .on("data", async function (event: any) {

            //let datetime = await axios.get('https://www.timeapi.io/api/Time/current/zone?timeZone=Australia/Sydney')
            let location = event.returnValues.location;
            let datetime = await axios.get(`https://www.timeapi.io/api/Time/current/zone?timeZone=${location}`)
                .then(async function (response: any) {
                    console.log(response.data.date)
                    return response.data.year*10000+response.data.month*100+response.data.day;
                })
                .catch(function (error: any) {
                    console.log(error);
                });
            console.log(datetime);
            // assume account balance is sufficient
            try {
                contract_instance.methods.respondDatePhase(datetime).send({
                    from: account.address,
                    gasPrice: gasPrice!,
                    gas: Math.ceil(1.2 * await contract_instance.methods.respondDatePhase(datetime).estimateGas({ from: account.address })),
                }).then(function (receipt: any) {
                    return receipt;
                }).catch((err: any) => {
                    console.error(err);
                });
            } catch (e) {
                console.log(e);
            }
        })
        //error catch
        .on("error", function (error: any, receipt: any) {
            console.log(error);
            console.log(receipt);
            console.log("error listening on event timeRequest");
        });

        //off-chain computation part this provide (index,date to expire)
        contract_instance!.events["checkRequest(uint256)"]()
        .on("connected", function (subscriptionId: any) {
            console.log("listening on event check");
        })
        //check off-chain
        .on("data", async function (event: any) {
            
            const date = await contract_instance.methods.date().call().then(function(response: any){
                
                return response;
            })
            console.log("this isdate"+date)
            
            const intcount = await contract_instance.methods.product_counter().call().then((response: any) => {
                console.log(response)
                return response;
            })
    
            var i:number;
            var conter:number = 0;
            var expiredate: number = 40000101;
            for (i = 0; i<intcount;i++){
                const expdate = await contract_instance.methods.getExpiredate(i).call().then((response:any) =>{
                    return response;
                })
                if (expdate<expiredate){
                    expiredate = expdate
                    conter = i
                }
            }
            const s:string = expiredate.toString()
            const s2:string = date.toString()
            const d = new Date(s.substring(0,4)+"-"+s.substring(4,6)+"-"+s.substring(6,8))
            const d2 = new Date(s2.substring(0,4)+"-"+s2.substring(4,6)+"-"+s2.substring(6,8))
            const dayexpire = (d.getTime()-d2.getTime())/(1000 * 60 * 60 * 24)
            console.log(conter,dayexpire)
            try {
                contract_instance.methods.checkresponsePhase(conter,dayexpire).send({
                    from: account.address,
                    gasPrice: gasPrice!,
                    gas: Math.ceil(1.2 * await contract_instance.methods.checkresponsePhase(conter,dayexpire).estimateGas({ from: account.address })),
                }).then(function (receipt: any) {
                    return receipt;
                }).catch((err: any) => {
                    console.error(err);
                });
            } catch (e) {
                console.log(e);
            }
    
            // assume account balance is sufficient
        })
        //error catch
        .on("error", function (error: any, receipt: any) {
            console.log(error);
            console.log(receipt);
            console.log("error listening on event");
        });

})();
